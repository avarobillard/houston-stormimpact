---
title: "Houston Winter Storm and Power Outage Analysis"
author: Ava Robillard
date: 10/30/25
format: html
execute:
  message: false
  warning: false
---
As climate change increases the frequency of extreme weather events, the impacts associated with these events are felt more intensely by the communities that live there. In February of 2021, Texas experienced a power crisis due to multiple severe winter storms. By understanding how the impact of losing power was felt across the Houston community, we can allocate resources and plan more strategically for future weather events.

**Objective**: Use VIIRS, OpenStreetMap, and U.S. Census data to visualize the impacts of the winter storms by estimating the number of homes in the Houston metropolitan area that lost power and combine this with socioeconomic data about median household income to investigate whether these impacts were disproportionately felt. 

## Load packages
```{r}
library(tidyverse)
library(stars)
library(sf)
library(terra)
library(tmap)
```

1. Load in all data 
```{r}
# Read in night light data tiles
tile1_2021_02_07 <- stars::read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021038.h08v05.001.2021039064328.tif"))

tile2_2021_02_07 <- stars::read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021038.h08v06.001.2021039064329.tif"))

tile1_2021_02_16 <- stars::read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021047.h08v05.001.2021048091106.tif"))

tile2_2021_02_16 <- stars::read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021047.h08v06.001.2021048091105.tif"))

# Combine tiles for each date into a single continuous raster- maps
lights_2021_02_07 <- st_mosaic(tile1_2021_02_07, tile2_2021_02_07)
  
lights_2021_02_16 <- st_mosaic(tile1_2021_02_16, tile2_2021_02_16)

# Visualize a combined tile
tm_shape(lights_2021_02_07) +
  tm_raster()
```


```{r}
# Read in roads data and filter to only class motorway
roads <- sf::st_read(here::here("data/gis_osm_roads_free_1.gpkg"), query = "SELECT * FROM gis_osm_roads_free_1 WHERE fclass='motorway'")

# Transform CRS
roads <- st_transform(roads, 3083)

# Read in buildings data and filter to only types of houses
houses <- sf::st_read(here::here("data/gis_osm_buildings_a_free_1.gpkg"), query = "SELECT *
FROM gis_osm_buildings_a_free_1
WHERE (type IS NULL AND name IS NULL)
OR type in ('residential', 'apartments', 'house', 'static_caravan', 'detached')")

# Transform CRS
houses <- st_transform(houses, 3083)
```

```{r}
# Read in entire geodatabase
socioeconomic <- st_read(here::here("data/ACS_2019_5YR_TRACT_48_TEXAS.gdb"))

# Explore socioeconomic geodatabase layers
layer_info <- st_layers(dsn = here::here("data/ACS_2019_5YR_TRACT_48_TEXAS.gdb"))
layer_info

# Create geometry layer
ACS_tract_geometry <- st_read(here::here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"), layer = "ACS_2019_5YR_TRACT_48_TEXAS")

# Create attribute layer
ACS_tract_attributes <- st_read(here::here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"), layer = "X19_INCOME")

# check CRSs here! 

# Combine layers
ACS_tracts <- ACS_tract_geometry %>% 
  left_join(ACS_tract_attributes, by = "GEOID")
```
```{r}
# Ensure data sets have same coordinate reference systems 
if(crs(roads) == crs(houses)) {
  print("Coordinate reference systems match")
} else{
  warning("Updating coordinate reference systems to match")
  # transform data to match
  boundary <- st_transform(roads, st_crs(houses))
}

if(st_crs(lights_2021_02_07) == st_crs(lights_2021_02_16)) {
  print("Coordinate reference systems match")
} else{
  warning("Updating coordinate reference systems to match")
  # transform data to match
  boundary <- st_transform(lights_2021_02_07, st_crs(lights_2021_02_16))
}

if(st_crs(lights_2021_02_07) == crs(roads)) {
  print("Coordinate reference systems match")
} else{
  warning("Updating coordinate reference systems to match")
  # transform data to match
  boundary <- st_transform(lights_2021_02_07, st_crs(roads))
}

if(st_crs(lights_2021_02_07) == st_crs(ACS_tracts)) {
  print("Coordinate reference systems match")
} else{
  warning("Updating coordinate reference systems to match")
  # transform data to match
  boundary <- st_transform(ACS_tracts, st_crs(lights_2021_02_07))
}
```


2. Find locations that experienced a blackout by creating a mask
```{r}
# Find the change in night lights intensity pre and post storm
# Check for same extent and resolution first
light_difference <- lights_2021_02_07 - lights_2021_02_16

# the following code was for a reclassification- probably don't need
#light_difference <- rast(light_difference)

# Reclassify the difference raster
#rcl <- matrix(c(-Inf, 200, 0, # values -Inf to 200 = 0
                #200, Inf, 1), # values 200 to Inf = 1
              #ncol = 3, byrow = TRUE)

# Apply the matrix to reclassify the raster, making all cells 0 or 1
#light_diff_rcl <- classify(light_difference, rcl = rcl)

# Assign NA to cells that experienced a change less than 200 nW cm-2sr-1
#light_diff_rcl[light_diff_rcl = 0] <- NA

# Assign NA to cells that experienced a change less than 200 nW cm-2sr-1
light_difference[light_difference < 200] <- NA


tm_shape(light_difference) +
  tm_raster(title = "Blackout Areas",
            palette = "-Blues")


# Vectorize the blackout mask and fix invalid geometries
light_diff_vec <- light_difference %>% 
  #as.polygons(na.rm = TRUE) %>% 
  st_as_sf() %>% 
  st_make_valid()

# Create bounding box for Houston area
bb <- st_bbox(c(xmin = -94.5, xmax = -96.5, ymax = 30.5, ymin = 29.0), crs = st_crs(4326))
houston_box <- st_as_sfc(bb)

# Spatially subset blackout mask to Houston area
light_diff_houston <- light_diff_vec[houston_box, ]

# Reproject to NAD83 / Texas Centric Albers Equal Area
light_diff_houston <- st_transform(light_diff_houston, crs = 3083)

tm_shape(light_diff_houston) +
  tm_polygons(title = "Blackout Areas")

# 0 is NA (false if less than 200) by indexing -> difference mask -> st_as_sf -> st_is_valid() -> st_make_valid() -> vector_difference_mask
# st_bbox or st_points -> convert to a layer using st_as_sf, in CRS4326
# st_intersects() or st_crop() -> st_transform()
```


3. Exclude highways from analysis

```{r}
#st_buffer -> look at st_crs$units -> st_union -> st_disjoint -> st_join/st_difference- returns areas ->
# use vector_difference and st_union for st_difference 

# Check units of CRS- meters
st_crs(roads)$units

# Create 200m buffer around all highways
highway_buffer <- st_buffer(roads, dist = 200)

# Combine buffer geometries 
highway_union <- st_union(highway_buffer) 

# Visualize buffer- 200m is small!
tm_shape(highway_union) +
  tm_polygons(col = "black") +
  tm_shape(roads) +
  tm_lines(col = "pink", lwd = 0.4) +
  tm_title(text= "200m highway buffer")

# Use st_disjoint to find areas that experienced blackouts further than 200m from a highway
true_blackouts <- light_diff_houston[highway_union, , op = st_disjoint] %>% 
   st_make_valid()

#true_blackouts <- st_difference(light_diff_houston, highway_union)

# Visualize true blackouts
tm_shape(true_blackouts) +
  tm_polygons()
```


4. Identify homes that experienced blackouts by combining the locations of homes and blackouts

```{r}
# map and summary stat
#buildings -> overlapped with areas non-highway and experienced a blackout- st_intersection/st_within/st_contains- changes interpretation (some homes fully within and partially within) -> homes that experienced blackout

# Filter homes to those that are contained within the true blackouts polygon
# sparse binary predicate list
blackout_houses_sgbp <- st_within(houses, true_blackouts)

# convert to logical vector
blackout_houses_logical <- lengths(blackout_houses_sgbp) > 0

# filter based on logical vector
blackout_houses <- houses[blackout_houses_logical, ]

tm_shape(blackout_houses) +
  tm_dots() 
```

5. Identify the census tracts likely impacted by the blackout

```{r}
#spatial join census data with homes that experienced blackouts, st_within or st_intersects
#data wrangling to summarize median income by census tract
```
